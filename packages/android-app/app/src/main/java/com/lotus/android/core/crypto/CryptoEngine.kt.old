package com.lotus.android.core.crypto

import android.util.Base64
import com.lotus.android.core.model.EncryptedBlobPayload
import java.nio.ByteBuffer
import java.security.MessageDigest
import java.security.SecureRandom
import javax.crypto.Cipher
import javax.crypto.Mac
import javax.crypto.SecretKey
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.PBEKeySpec
import javax.crypto.spec.SecretKeySpec
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

private const val AES_GCM_TAG_BITS = 128
private const val AES_GCM_IV_SIZE = 12

class CryptoEngine {
  private val json = Json { ignoreUnknownKeys = true }
  private val rng = SecureRandom()

  fun deriveMasterKey(masterPassword: CharArray, salt: ByteArray, rounds: Int = 210_000): ByteArray {
    val spec = PBEKeySpec(masterPassword, salt, rounds, 256)
    val factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
    return factory.generateSecret(spec).encoded
  }

  fun deriveSubKey(masterKey: ByteArray, context: String): ByteArray {
    val prk = hmacSha256(ByteArray(32), masterKey)
    val info = context.toByteArray(Charsets.UTF_8)
    return hkdfExpand(prk, info, 32)
  }

  fun encryptUtf8(plainText: String, key: ByteArray, aad: String): EncryptedBlobPayload {
    val iv = ByteArray(AES_GCM_IV_SIZE).also(rng::nextBytes)
    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
    val secret: SecretKey = SecretKeySpec(key, "AES")
    cipher.init(Cipher.ENCRYPT_MODE, secret, GCMParameterSpec(AES_GCM_TAG_BITS, iv))
    cipher.updateAAD(aad.toByteArray(Charsets.UTF_8))
    val encryptedWithTag = cipher.doFinal(plainText.toByteArray(Charsets.UTF_8))

    val ct = encryptedWithTag.copyOfRange(0, encryptedWithTag.size - 16)
    val tag = encryptedWithTag.copyOfRange(encryptedWithTag.size - 16, encryptedWithTag.size)
    return EncryptedBlobPayload(
      v = 1,
      alg = "AES-256-GCM",
      iv = iv.b64(),
      ct = ct.b64(),
      tag = tag.b64(),
      aad = aad
    )
  }

  fun decryptUtf8(payload: EncryptedBlobPayload, key: ByteArray, aad: String): String {
    require(payload.alg == "AES-256-GCM") { "Unsupported algorithm: ${payload.alg}" }
    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
    val iv = payload.iv.b64ToBytes()
    val ct = payload.ct.b64ToBytes()
    val tag = payload.tag.b64ToBytes()
    val full = ByteBuffer.allocate(ct.size + tag.size).put(ct).put(tag).array()

    cipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key, "AES"), GCMParameterSpec(AES_GCM_TAG_BITS, iv))
    cipher.updateAAD(aad.toByteArray(Charsets.UTF_8))
    return String(cipher.doFinal(full), Charsets.UTF_8)
  }

  fun computeIntegrityHash(entryIds: List<String>, syncVersion: Long): String {
    val canonical = entryIds.sorted().joinToString("|") + "|$syncVersion"
    val digest = MessageDigest.getInstance("SHA-256")
    return digest.digest(canonical.toByteArray(Charsets.UTF_8)).toHex()
  }

  fun serializePayload(payload: EncryptedBlobPayload): String = json.encodeToString(payload)
  fun parsePayload(serialized: String): EncryptedBlobPayload = json.decodeFromString(serialized)

  fun wipe(bytes: ByteArray) {
    for (i in bytes.indices) bytes[i] = 0
  }

  private fun hmacSha256(key: ByteArray, data: ByteArray): ByteArray {
    val mac = Mac.getInstance("HmacSHA256")
    mac.init(SecretKeySpec(key, "HmacSHA256"))
    return mac.doFinal(data)
  }

  private fun hkdfExpand(prk: ByteArray, info: ByteArray, len: Int): ByteArray {
    var counter = 1
    var output = ByteArray(0)
    var t = ByteArray(0)
    while (output.size < len) {
      val data = ByteBuffer.allocate(t.size + info.size + 1)
        .put(t)
        .put(info)
        .put(counter.toByte())
        .array()
      t = hmacSha256(prk, data)
      output += t
      counter += 1
    }
    return output.copyOf(len)
  }
}

private fun ByteArray.b64(): String = Base64.encodeToString(this, Base64.NO_WRAP)
private fun String.b64ToBytes(): ByteArray = Base64.decode(this, Base64.DEFAULT)
private fun ByteArray.toHex(): String = joinToString("") { "%02x".format(it) }
